# 学习笔记

* 思考题答案：简单来说，不允许改变first-line的和模型的原因就是它所包含的内容是不能预先确定的，而first-letter不存在这个问题。first-line伪类的一个可能实现是，当我正在渲染的文本可以匹配到一个定义了first-line伪类选择器的css规则时，可以应用这一规则渲染当前文本的每一个字符，直到排满第一行后即可将这些规则去除再渲染剩余文本。也就是说，first-line的盒必然只能有一行内容。如果可以对first-line进行float和盒模型调整，那么渲染剩余文本时，它们就可以和first-line盒排在同一行的后面，那么究竟是否应该继续对这些视觉上处在第一行的文本应用first-line规则呢？如果应用，就会违反first-line中定义的样式，如果不应用，那这些字符就不应该和first-line处于同一行，这样循环定义的悖论在逻辑上就是无法解决的，所以first-line伪类是不可以修改盒模型的。

* CSS语法分为at-rule和普通rule两部分。除charset和import外，每条rule又分为选择器与样式两部分。样式的每一条内容由键值对构成。

* 关于at-rule：
  1. @page: 页面在分页媒体上的表现，如打印机和阅读器
  1. @media: media-query，有条件的应用css规则
  1. @counter-style: 定义列表前缀（点或序号）的样式
  1. @keyframes: 定义动画关键帧
  1. @fontface: webFont定义
  1. @support: 查询css特性的兼容性，但本身是一个新特性，只应该用于监测未来出现的更新的特性
  1. @namespace: 命名空间，目前只有HTML，SVG和MathML

* 简单选择器：
  1. \* 全体选择
  1. tagName选择器
  1. . 类选择器
  1. \# 元素id选择器
  1. \[\] 属性选择器
  1. : 伪类选择器
  1. :: 伪元素选择器

* 复合选择器：
  * 将简单选择其直接连在一起，表示需满足全部条件
  * \*和tagName需写在最前面
  * 伪类和伪元素一定要写在最后

* 复杂选择器
  * 空格连接：前面匹配祖先节点，后面匹配子孙节点
  * \>连接：前面匹配直接父节点，后面匹配直接子节点
  * ~、+连接：表示邻接关系
  * ||连接：（css level 4）表格中选择列

* 选择器列表：多个选择器使用同一个样式规则

* 优先级：表示选择器规则与所匹配元素的匹配程度，更匹配的规则所对应的样式可以覆盖匹配度较差的选择其对应的样式。优先级可以看作一个进制足够大的四位数。元素inline规则在最高位，id选择器在次一位，class选择器在第三位，tagName选择器在最后一位。

* 伪类：
  * 状态型：
    1. :any-link :link :visited 用于超链接，只能更改文本颜色（为了保护用户隐私）
    1. :hover :active :focus :target
  * DOM树匹配：
    1. :empty
    1. :nth-child() :nth-last-child()
    1. :first-child :last-child :only-child
  * 逻辑型：
    1. :not() 不支持在表达式中写复杂选择器
    1. :where :has （css level 4）
  * 出于性能问题，不要在复杂伪类中写太复杂的表达式

* 伪元素：
  * 内容中插入元素：::before ::after
  * 把内容中的一部分当作特殊元素：::first-line ::first-letter
